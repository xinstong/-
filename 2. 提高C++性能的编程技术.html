<html>
<head>
  <title>2. 提高C++性能的编程技术</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 18pt;
    }
  </style>
</head>
<body>
<a name="3532"/>
<h1>2. 提高C++性能的编程技术</h1>

<div>
<span><div>1、win32平台上互斥锁和临界区的区别？</div><div>互斥锁可以跨越进程来达到不同进程中运行的线程同步；而临界区只限制在同一个进程中使用。</div><div><hr/></div><div>2、过分复杂的数据类型相当于散漫的编程风格，这将会导致不必要的过分行为，而不是坚持了最开始的原则：尽可能使用最简单的解决方案。</div><div><hr/></div><div>3、无法内联虚函数是虚函数的最大性能损失。但是虚函数有时候也可以被内联，硬编码的时候如此。而是用模板可以来把计算虚函数地址从运行时提前到编译时，来提高效率。</div><div><br/></div><div><a href="https://stackoverflow.com/questions/733737/are-inline-virtual-functions-really-a-non-sense">https://stackoverflow.com/questions/733737/are-inline-virtual-functions-really-a-non-sense</a></div><div><img src="2. 提高C++性能的编程技术_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><img src="2. 提高C++性能的编程技术_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><img src="2. 提高C++性能的编程技术_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><br/></div><div><br/></div><div><hr/></div><div>4、任何时候只要跳过了对象的创建和销毁，就能提高执行你个效率。</div><div>返回值优化【不要使用临时变量，编译器会进行RVO优化】，临时对象优化。</div><div><img src="2. 提高C++性能的编程技术_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div><hr/></div><div>5、自己设计内存池，在一定的假设条件下，内存的管理可以提高效率。</div><div>是否是单线程，多线程里面的锁的优化。</div><div><hr/></div><div><span style="font-size: 18pt; font-family: 宋体;">6、内联调用优化，inline或者直接将实现定义在声明的时候。不是强制的，内不内联看编译器的决定。</span></div><div><span style="font-size: 18pt; font-family: 宋体;">如何使用内联呢？</span></div><div><span style="font-size: 18pt; font-family: 宋体;">    1、直接在声明的地方实现小函数，此时inline前缀写不写无关系。</span></div><div><span style="font-size: 18pt; font-family: 宋体;">    2、在声明的地方不加inline，而在头文件中定义该函数，并且前面加上inline关键字，注意实现必须放到头文件中。</span></div><div>内联 调用间优化，有时候不是所有地方都要内联，如果要内联的函数较大，会大大地增大程序大小，造成一些负面影响，比如缓存失败或者页面错误等。</div><div>什么时候内联呢？</div><div>    唯一调用点（不是调用次数）；</div><div>    微小（小于5行有效代码）的函数；</div><div><hr/><div>7、通过内联开关[宏定义，可以通过编译参数来]来测试是否要内联，是否内联代价过大。将内联的函数放到.inl文件中，决定是头文件中包含该内联文件，还是cpp文件中包含。</div><div><span style="color: rgb(255, 0, 0);">选择性内联，可以实现两个版本，不内联的版本调用内联版本来保持程序员只用维护一个版本。【太棒了】</span></div></div><div><hr/></div><div>8、内联时编译器对于带有静态变量的方法的处理很难受：</div><div>不内联还是内联后创建不同的方法实例，对于不同的编辑器选择不同。当前的语言规范要求编译器对于内联方法进行外部链接，但是不同的编译器处理的方法不一样。</div><div><span style="color: rgb(227, 0, 0);">内联在当前多寄存器集的时候，发挥出来的防止调用被调用重复压栈出栈的效果可能越来越小了。但是调用深度越大，可能寄存器会溢出到内存上，而此时，内联的间接效果可能显现出来。</span></div><div><span style="color: rgb(227, 0, 0);">总之，是否需要内联，需要测试来决定。</span></div><div><hr style="color: rgb(227, 0, 0);"/><div>9、标准模板库</div></div><div>    渐进复杂度</div><div>函数指针必须在运行时才能进行确定，所以干扰到了编译器的内联。</div><div>函数对象可以让编译器自由地内联。</div><div><br/></div><div>改进STL，在某些情况下，如果对list使用size()函数频繁的话，可以考虑缓存一个变量保存元素个数。</div><div><hr/></div><div>10、引用计数</div><div>内存问题主要包含：1，内存泄漏；2，过早删除。</div><div>引用计数可以帮忙解决这两个问题，但是执行效率上不一定有帮助。</div><div><hr/>
11、代码优化</div><div>for循环内不修改的计算可以放在循环外；</div><div>空间换时间，比如缓存；</div><div>预先计算；</div><div>80-20规则：提高常用路径的效率。条件判断的时候，表达式中尽快确定结果的条件放在前面。</div><div>缓式计算：在C中要求所有变量都要定义在函数开头的地方，而C++中没有这个要求，同时如果所有变量对象都定义在函数开头的地方的话，马上出发的构造函数可能是不需要的。影响了效率。</div><div>无用计算。</div><div>缓存失败造成的性能浪费，在类定义的声明顺序中，小的变量最好一起放在一块，不要被大的成员插在中间，否则容易缓存失败，造成指令的浪费。</div><div>内存管理，new还有delete性能上不如局部变量，但是会失去灵活性。</div><div><hr/></div><div>12、设计优化</div><div>灵活性和性能之间的斗争。博弈。</div><div>无用代码、失效代码清理。缓存计算、延迟计算。</div><div><hr/></div><div>13、可伸缩性</div><div>总线成为SMP系统的主要瓶颈。缓存一致性问题。锁竞争会激发缓存不一致，这是SMP系统的薄弱之处。</div><div>拆分任务，充满CPU占有率。</div><div>缓冲共享数据，pthread库支持线程私有指针，可以通过pthread_setspecific()[get]来操作。但是这有时会激发锁竞争，所以可以通过将私有数据的指针当作参数压入堆栈，来降低get的次数来缓解锁竞争。</div><div>部分共享数据时可以通过散列竞争线程到不同的共享资源上来降低整体的锁竞争。</div><div>锁的粒度问题。</div><div>伪共享问题：在同一个缓存行（128byte）的时候，类定义中两个锁如果很近，这两个锁又是很紧密地执行，在不同的CPU核上会造成第二个锁命中失败，影响效率。</div><div>简单锁在线程请求加锁失败时，会休眠所有线程，当锁可用时，在唤醒所有的线程，而此时如果唤醒的线程数目大于1，就会出现Thundering Herd，因为此时只能有一个线程获得锁，但是很多线程一起被唤醒并且马上继续休眠等待锁可用时的唤醒，这回造成线程上下文切换的浪费。</div><div>读写锁来降低锁的竞争。</div><div><hr/></div><div>13、系统体系结构相关性。</div><div>磁盘和内存结构：顺序访问/不经常修改的文件可以使用线性文件结构或者索引文件结构，大型数据集的运行管理需要与虚拟内存机制更为接近的存储机制。</div><div>比如二分查找上亿的数据，虽然复杂度很低，但是如果数据量过大的情况下会造成页面错误，每次页面错误造成的时钟浪费很严重。需要换一种思路来解决。</div><div>升级硬件也是一种性能优化方法。</div><div>缓存影响。缓存颠簸。</div><div>避免跳转，很多跳转的短代码不一定会比直线型的长代码快。</div><div>上下文切换，线程开销。</div><div><hr/></div><div>《完》<span style="font-size: 17pt;">2018/3/16 23:15</span></div><div><br/></div><div><br/></div></span>
</div></body></html> 