<html>
<head>
  <title>4. 深入C++对象模型</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 18pt;
    }
  </style>
</head>
<body>
<a name="3558"/>
<h1>4. 深入C++对象模型</h1>

<div>
<span><div>    <span style="font-weight: bold;">关于对象</span><br/></div><div>1、C++对象模型：</div><div>    1、语言中直接支持面向对象程序设计的部分；</div><div>    2、对于各种支持的底层实现机制。</div><div><hr/></div><div>2、ADT（abstract data type）抽象数据类型。</div><div>封装C++在布局和存取时间上造成的负担主要是virtual函数引起的。包含两方面，</div><div>    a、virtual function 机制（用以支持一个有效率的“执行器绑定”）；</div><div>    <img src="4. 深入C++对象模型_files/Image.png" type="image/png" data-filename="Image.png"/></div><div>    b、virtual base class（用以实现多次出现在继承体系中的base class，有一个单一而被共享的实体）。</div><div><hr/></div><div>3、虚继承，即共享继承，base class只会保持一个实体。</div><div>    关键字差异，为了维持跟C语言的兼容性，在识别是表达式还是声明时，C++很费力。</div><div>    struct和class替代问题。</div><div><hr/></div><div>4、组合来保证C struct对于内存布局上与C语言兼容。</div><div><hr/></div><div>5、程序设计典范除了面向对象设计，哈哈，其实还有很多。</div><div>    <img src="4. 深入C++对象模型_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><hr/></div><div>6、多态调用，子类赋值给父类时可以使用指针或者引用（底层也是指针），而不能使用对象赋值，否则会切片的。</div><div>父类对象的函数调用，有可能是通过virtual机制或者不采用，都会调用自身的函数。这就是所谓的编译素养问题。此时编译器会屏蔽掉virtual机制。</div><div><hr/></div><div>7、一个类对象要有哪些内存来展现自己？</div><div>    非静态数据成员的总和大小；<br/></div><div>    为了提高bus的传输效率而填补的对齐自己总和；<br/></div><div>    virtual机制带来的负担。<br/></div><div>指针类型会教导编译器解释某一个指针指向的内存内容以及大小。</div><div><hr/></div><div>8、C++通过pointer和reference来实现多态，这种设计风格就是面向对象，而OB（基于ADT的程序风格），面向对象有弹性，但是因为virtual机制而增加了负担，Object-based没有负担，但是却没有弹性。</div><div><hr/></div><div>        <span style="font-weight: bold;">构造函数语意学</span><br/></div><div><br/></div><div>9、默认构造函数什么时候合成出来？</div><div>在编译器需要的时候，而不是类设计者需要的时候。暗中被声明的默认构造函数是一个浅薄而无能，没啥用处的构造函数。</div><div>有用的默认构造函数是在编译器需要的时候合成出来的，设计者需要的时候合成的默认构造函数并不能被类设计者所需要。【什么时候合成呢？在被调用构造函数的时候才。】</div><div>默认是否被清零的规则是这样的，全局的对象变量会被清零，而局部的或者堆上的，都不会被清零，而是计算机内存上上次被使用而留下来的痕迹。</div><div>a. 在还有带有默认构造函数的类成员时，构造这个类成员就是编译器的责任，此时会在调用包含类的构造函数时，合成一个默认构造函数。但是如果还有另为的不带默认构造函数的成员对象时，构造这些成员就是程序设计者的责任，所以他自己定义了个构造函数，此时编译器还需要构造带有默认构造函数的成员呢，该怎么办呢？编译器会修改这个函数，扩张一些调用成员的默认构造函数。</div><div>问题：在编译不同的CPP模块时，编译器如何避免合成中多个默认构造函数呢？简单的使用内联函数，如果函数太复杂，就会合成中一个explicit non-inline static 实体出来。</div><div>b. 继承自带有默认构造函数的基类</div><div>c. 带有一个虚函数的类</div><div>d. 带有一个虚基类【虚继承】的类</div><div><hr/><div>10、默认拷贝构造函数何时编译器会生成一个出来呢？</div></div><div>    数据成员或者基类带有拷贝构造函数，自身或者基类带有虚函数。</div><div>何时要用户来显式提供一个拷贝构造函数呢？如果不符合编译器自动合成一个默认构造函数的时候，使用bitwise来拷贝是安全和高效的。但是如果需要memberwise的时候，为了返回值优化，最好声明一个显式的inline拷贝构造函数。</div><div><hr/></div><div>11、初始化列表是函数调用吗？不是的。编译器会在构造函数的开头地方插入一些代码。编译器承诺会在用户显式的构造函数代码之前。</div><div>初始化顺序取决于类定义时的声明顺序。可以使用一个成员函数来为一个数据成员来赋值。但是要考虑不能是继承类的成员函数，并且该函数内不要使用其他数据成员。</div><div><hr/><div>    <span style="font-weight: bold;">语义学</span></div></div><div>12、对于空的类的对象，编译器会安插进入一个byte，来保证他们的对象在内存上有不同的地址。</div><div>此处的空是指没有成员数据，如果有成员函数，也算是空的。</div><div>静态数据不放在对象的内存空间里，而是放在全局数据段里面。但是模板类的存放有点缺别，为什么呢？因为此时模板类所代表的类还没实例化呢？实例化了吗？真的吗？</div><div>虚基类和虚函数的实现细节，C++标准并没有明确指出，这部分的实现由专家厂商来自由发挥。</div><div>类对象的大小来源：本身非静态数据成员、字节对齐、编译器追加的语言特性比如虚拟。</div><div><hr/></div><div>13、防御性风格，虽然数据成员绑定是在一个类声明完成之后开始绑定，但是成员函数的参数列表的类型决议（比如typedef定义的类型到底是哪个typedef，全局的还是本类的）是在扫描类声明时就开始的，而不是在扫描之后。而此时为了防御全局定义的侵入，需要把局部定义放置到类的最开始的地方。</div><div><hr/></div><div>14、类成员数据绑定 C++标准规定非静态数据成员在声明顺序上后来出现的位于高字节上，而它们在对象内存上排布可能不是连续的，中间可能插入一些对齐字节。而其他语言特性而加入的其他东西比如续表可以放置到这些数据成员的中间、前面、后面的任何位置，C++标准不做定义。由编译器任意实现。C++标准允许编译器自由排列不同访问级别的成员数据集和之间的顺序，但是目前还没有编译器会这样干。分不同的访问级别区块不会加大对象内存的负担。</div><div>静态成员数据只会维护一个实体，无论是继承来的或者虚继承过来的，还是自己的成员，存取上会直接使用访问全局数据区，存取路径直截了当。而是用指针或者对象来存取数据只是语法上的方式，会被编译器转换成（类::静态成员）的方式。除了<span style="line-height: 1.45;">通过函数返回的对象来存取返回值对象的静态数据时，C++标准要求对对象求值，然后再直接存取静态数据。</span></div><div><span style="line-height: 1.45;">如果两个类，有同样名字的静态成员数据时该怎么办呢？编译器有一种name-mangling的算法来装饰修改名字保证唯一性。这样的算法有个要求，一是算法要统一，可以推导出独一无二的名字出来；二是万一编译器需要跟用户沟通，需要再反推导回去原来的名字。</span></div><div><hr/></div><div><span style="line-height: 1.45;">15、非静态函数只要出现了对于非静态数据的存取，就会隐含有一个类对象出现，也就是this指针。CClass const* this作为第一个参数插入到成员函数的参数列表里面。</span></div><div><span style="line-height: 1.45;">存取实现机制是对象地址加上（成员数据偏移量-1）；</span></div><div><span style="line-height: 1.45;">使用对象和指针来存取成员的区别是，如果该成员是虚基类继承过来的话，对象可以让编译器在编译的时候就可以确定下来该怎么存取这个成员，而指针要推迟到执行的时候才可以确定下来。确定下来什么呢？</span></div><div><hr/></div><div><span style="line-height: 1.45;">16、继承的数据成员和自己的数据成员的内存对象顺序并没有在C++标准里面明确说明，但是大部分编译器是把继承的放到前面，但是虚拟继承类的除外。</span></div><div>虚拟继承并不会额外增加空间或者存取上的负担。</div><div>C++标准保证在继承类的对象中保持着基类的完整原样性。</div><div><hr/><div>17、虚函数表带来的时间和空间上的负担有哪些？</div></div><div>  a、为类引入一个虚函数表，存放所有的虚函数，再加入一到两个solts，去支持运行时类型识别。</div><div>  b、为对象引入一个指针，指向虚函数表。</div><div>  c、构造函数和析构函数的处理。</div><div><hr/></div><div>18、多重继承 虚拟继承</div><div><hr/><div>19、当优化开关打开的时候，封装并不会带来负担。</div></div><div>每一个真正的member set都被加上了1，为了区分没有指向任何数据，和指向第一个类成员的问题。</div><div><hr/><div>     function语意学</div></div><div>20、C++的设计准则规定，非静态成员函数比非成员函数<span style="color: rgb(255, 0, 0);">不能有</span>额外的负担。所以编译器厂商会在编译器中将成员函数实体转换为对等的非成员函数实体，怎么转换呢？</div><div>第一步：就是改写函数原型，添加额外的this指针来提供存取管道，让对象可以调用该成员函数，所以this指针必须指向该对象。如果是const的成员函数，该指针还必须指向该对象的const版本。</div><div>第二步：改写非静态数据成员，添加this指针。</div><div>第三步：将成员函数重新写为一个外部函数，对函数名进行mangling处理【使之成为全局唯一的名称。】</div><div><hr/><div>21、mangling处理的对象：</div></div><div>类名称；类成员函数；类成员；类的虚函数表指针【因为可能一个对象有多套虚函数表，明确的调用可以压制虚拟机制，使用inline方式也可以】；</div><div>静态成员函数，需要隐式的对象来存取静态数据成员时用0强转为一个类的指针，但是最新的编译器强调没有this指针；所以有以下特性：不能存取其类中的非静态成员；不能被声明为const,volatile,virtual；不需要经由object来调用。放在class声明之外，使用mangling处理成合适的名字。取其地址，是指向一个非成员函数的指针。</div><div>因为缺乏this指针，所以差不多等于非成员函数，这样可以提供一个意想不到的好处是成为一个callback或者为线程所使用。</div><div><hr/><div>22、虚成员函数</div></div><div>为了在执行器正确调用，需要每一个对象有一个虚函数指针，来指向本类的虚函数表，虚函数表中第个slot里面放置类型信息，之后都是函数实体的地址。</div><div>每一个类一般有一个表，但是多重继承的可能有多个表。一般情况下会将它们链接到一起作为一个具名的虚表。</div><div>虚函数要求一般最好是八行代码，这样的话，有些编译器优化的时候，针对多重继承，会产生两个同样算法的函数实体，第二个函数实体会在函数返回前，修改this指针的offset，自动</div><div><img src="4. 深入C++对象模型_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><img src="4. 深入C++对象模型_files/Image [3].png" type="image/png" data-filename="Image.png"/></div><div><hr/></div><div>23、虚基类：被虚继承的类，不是说类本身是个虚基类，只是说明在某一次的继承关系中，该类承担了虚基类的名义。在虚基类中最好不要声明非静态的成员数据，否则会很复杂。</div><div>纯虚基类：带有纯虚函数的类</div><div>虚函数：virtual修饰的成员函数（禁止修饰静态函数）</div><div><hr/><div>24、指向成员函数的指针如何实现虚拟机制呢？</div></div><div>非静态成员函数取地址，可以得到在内存中的值。</div><div><hr/><div>            <span style="font-weight: bold;">构造、析构、拷贝语意学</span></div></div><div>25、纯虚拟析构函数必须重写。因为每一个的继承类的析构函数会静态调用每一个虚基类和上一层的析构函数，因此缺乏任何一个都会造成链接失败。</div><div><hr/>
26、析构函数在用户没有明确定义出来的情况下，不一定会编译器合成出来，是否合成，需要编译器看是否成员带有析构函数或者是基类是否带有析构函数。</div><div><hr/><span>    <span>    </span><span>    执行期语义学</span></span></div><div><span>27、析构函数安插在区段的离开点之前。把对象的定义放置到使用的地方附近，可以节省不必要的对象构造和析构操作。全局对象的生命期就在main函数里面。全局对象静态初始化，可能需要跨越模块。</span></div><div><hr/>
28、局部静态对象：保证构造函数和析构函数只能被调用一次。如何保证呢？使用静态的全局指针来判断是否为空。</div><div><hr/>
29、对象数组，如果是具名数组会调用特殊的数组分配函数来处理，要是不是具名的，则跟指针没什么区别来处理。</div><div><hr/>
30、delete函数会判断指针是否为空的，所以delete NULL;没事的。</div><div>new char[0]，也会返回一个元素的地址的。</div><div><img src="4. 深入C++对象模型_files/Image [4].png" type="image/png" data-filename="Image.png"/></div><div>指针数组的大小保存在哪里呢？在内存区域块内配置额外的word。</div><div>删除数组指针时，不能delete一个指向子类对象数组的基类指针，这样的话，只会调用基类的析构函数。</div><div><hr/>
31、反聚合优化，减少堆栈存取。</div><div><hr/><span>    <span>    </span><span>    站在对象模型的尖端</span></span></div><div><span>32、声明一个指向模板类对象的指针，编译器不会将模板具现出来，因为指针不是对象，所以不需要知道该类的细节。但是引用的时候，是会具现出来的。</span></div><div><hr/></div><div>33、整形常量不能赋值给一个指针，除非是零。</div><div><hr/>
34、模板中名字的决议方式：对于非成员的名字，如果它与用于具现模板的参数类型无关，就有模板定义模块来决定，否则的话，就是用模板具现的模块区域来决议。</div><div><hr/>
35、为什么说RTTI是EH（Exception Handling）所产生的呢？</div><div>因为编译器要找到catch子句，处理丢出来的异常，这时候需要知道异常类型，也就是执行器类型识别。</div><div>CFront4.0的取消并不是因为没法处理异常：</div><div><img src="4. 深入C++对象模型_files/Image [5].png" type="image/png" data-filename="Image.png"/></div><div><hr/></div><div>36、RTTI dynamic_cast如果对于引用类型的，是不能使用的，因为引用如果返回一个0的话，会产生一个临时对象。</div><div><hr/><font style="font-size: 17pt;"><span style="font-size: 17pt;">2018/4/3 16:41 完</span></font></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 