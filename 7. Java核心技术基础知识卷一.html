<html>
<head>
  <title>7. Java核心技术基础知识卷一</title>
  <basefont face="宋体" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="Evernote Windows/307027 (en-US, DDL); Windows/10.0.0 (Win64);"/>
  <style>
    body, td {
      font-family: 宋体;
      font-size: 18pt;
    }
  </style>
</head>
<body>
<a name="3714"/>
<h1>7. Java核心技术基础知识卷一</h1>

<div>
<span><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">1、类的数字签名保证安全性。Java强类型语言。C++/C是弱类型语言。</span></div><div><hr/></div><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">2、类java代码-&gt;编译成字节码-&gt;java虚拟机（可以有选项配置成直接将频繁代码编译为机器码）-&gt;解释为机器码。</span></div><div><hr/></div><div><span style="font-size: 24px; font-family: &quot;courier new&quot;, courier, monospace;">3、JRE有虚拟机，但是没有编译器； JDK开发人员使用。</span></div><div><hr/></div><div><span style="font-size: 24px;">4、类名和文件名字必须一样，否则编译不过，会报错：</span></div><div>Exception in thread &quot;main&quot; java.lang.Error: Unresolved compilation problem:</div><div>main函数必须是静态公有的。静态是因为不需要通过对象来调用。</div><div><hr/></div><div>5、区分大小写，类名必须是字母，下划线打头，数字不能打头。</div><div>main函数必须是静态的。语句要用分号作为结束符。</div><div><span style="font-size: 24px;">println（带换行符） vs print（不带换行符）</span></div><div><hr/></div><div><span style="font-size: 24px;">6、注释：</span></div><div><span style="font-size: 24px;">单行：</span></div><div><span style="font-size: 24px;">//</span></div><div><span style="font-size: 24px;">多行：</span></div><div><span style="font-size: 24px;">/*</span></div><div><span style="font-size: 24px;">*/</span></div><div><span style="font-size: 24px;">doc:</span></div><div><span style="font-size: 24px;">/**</span></div><div>*</div><div>*/</div><div><hr/><div>7、数据类型：内存大小固定，不像C++与平台还有关。</div></div><div>八种：</div><div>四种整形 byte（1个字节）； short（2个字节）； int（4个字节）； long(8个字节） ；</div><div>长整型（数值后面带个L）；</div><div>进制：</div><div>十六进制 前带0x</div><div>八进制 前带0</div><div>二进制 前带 0b</div><div>数字里面可以带下划线（易读）；</div><div>二种浮点型：</div><div>float 4个字节，后带F</div><div>double 8个字节，后带D或者啥也不带。使用指数来表示P，指数是二。</div><div>一种char型：</div><div>一种boolean类型：</div><div><hr/></div><div>8、变量：名称必须是字母（包括下划线）开头，还有其他unicode字符。可以使用Character类中的isJavaIdentifierStart和isJavaIdentifierPart来判断。</div><div>尽管$是合法的字符，但是不要用，它出现在java编译器中。</div><div>类似C++，可以在一行中声明多个变量，但是不提倡这样做。</div><div>与C++一样，提倡将变量定义声明的地方与第一次使用的地方放置到一起去。有些路径不使用的话，就不用加载或者调用构造函数了。</div><div>与C++不一样的地方是，Java不区分声明和定义。</div><div><hr/></div><div>9、常量使用final来指示。</div><div><hr/><div>10、Java移植性与浮点数运算符 是否截断计算。使用strictfp关键字将严格浮点计算，不进行截断，可能会溢出。</div></div><div><hr/><div>11、位移运算符 消除了C++的模糊性。</div></div><div>&gt;&gt;&gt; 逻辑右移 使用0来填充高位；</div><div>&gt;&gt; 代数右移，使用高位来填充高位。</div><div><hr/><div>12、逗号运算符只允许在for循环中使用。</div></div><div><hr/><div>13、String在Java中是字符串指针，而不是字符数组。Java虚拟机负责内存问题。</div></div><div>所以比较字符串是否相等，使用的是equal或者CompareTo而不能使用==直接来比较。</div><div><div>字符串是否是空串，要想跟null比较，然后在判断length是否是0.</div><hr/></div><div>14、输入输出：System.out.println/print</div><div>Scanner（普通输入）。 console(适合密码输入）</div><div>Scanner 可以用于文件读取；PrintWriter用于文件写。</div><div><hr/></div><div>15、控制块，与C++类似，在同一个嵌套块内不能有同名的变量。</div><div>没有goto，但是有break 标签；其中标签必须放在循环外面，然后后面紧跟冒号。跳出语句块。不能跳入语句块。</div><div><hr/><div>16、大数值：Java不提供重写操作符。</div></div><div><hr/><div>17、数组 int[] a; 要new出来， 默认初始化为null。与C++中的数组指针很类似。但是不能指针运算得到下一个元素。</div></div><div>多维数组和不规则数组。多维数组相当于数组的数组。</div><div><hr/><div>18、命令行参数里面没有包含程序名。</div></div><div><hr/><div>19、超类Object，java中所有的类的顶级基类。</div></div><div><hr/><div>20、类关系：</div></div><div>    依赖 use-a</div><div>    聚合 has-a</div><div>    继承 is-a</div><div><hr/></div><div>21、对象变量只是引用一个变量，而不是包含一个对象。与C++里面的引用区别，java中可以赋值或者为null。与C++里面的指针很类似。空指针的处理不同，java中会报一个运行时错误，而C++会产生一个随机的位置出来。</div><div>局部变量不能自动初始化为null。</div><div><hr/><div>22、Java中单独的分开保存时间和时间点命名为两个类：</div></div><div>Data和GregorianCalendar;</div><div><hr/><div>23、Java中访问器函数没有指定const的语法。</div></div><div><hr/><div>24、Java编译器可以自动编译，如果依赖的类源文件更新的话。</div></div><div>可以使用javac file*.java通配符来批量编译文件，也可以自动寻找import的文件来编译。</div><div><hr/><div>25、java类的构造器必须必须在new一起使用，也就是申请在堆上。可以有多个。</div></div><div>在所有的方法中不要使用于实例域同名的变量名。</div><div>在方法中参数列表的第一个地方会有一个隐含的this引用对象，这个跟C++很像啊，同理为什么是第一个呢，默认参数的问题。</div><div>java中方法都是定义在函数内部的，但是不一定是内联的，是否内联是java虚拟机的任务。</div><div>访问器不要返回对实例域的引用，因为这样会修改它。可以使用clone方法。</div><div>方法里面可以访问类的所有对象的私有数据。同C++。</div><div>final 实例域表示构造器里面必须对之初始化，之后不再需要修改的实例成员。</div><div>static同C++；</div><div>方法参数是对基础类型按照值调用，而不是引用调用；对对象参数是也是值调用【因为引用的对象没有改变，只是引用对象的内容可以改变，也就是可以改变一个对象参数的状态，但是不能让对象参数引用一个新的对象】。基础类型参数不会修改参数，但是对象参数可以修改参数。对象引用和其他的拷贝引用的是同一个参数。</div><div>C++可以通过&amp;表示参数是引用对象调用。</div><div><hr/><div>26、方法重载 包括构造器方法和其他方法</div></div><div>重载解析 同C++。</div><div><hr/></div><div>27、默认域初始化 Boolean 为false；对象为null。</div><div>显式域初始化，可以在类定义时，直接将一个值【或者调用一个方法】赋值给任何域。</div><div>同时又可以在构造器中初始化，也可以通过初始化块【如果是静态域初始化，要用静态初始化块】来初始化。</div><div>参数名可以前加a或者使用this对象在构造器里面与参数名区分开来，一般不使用m_来区分。</div><div>与C++不同的是，在java构造器方法里面可以调用其他的构造器。</div><div>可以通过静态初始化块打印一句话，执行一个程序类似的。</div><div><hr/></div><div>28、Java析构函数不用支持。可以使用finalize方法来调用需要在虚拟机回收对象前调用，但是这样的话什么时候调用并不确定，如果需要立即关闭可以使用人工管理，close函数。</div><div><hr/></div><div>29、包 可以嵌套，每一个嵌套包在编译器的角度看来，都没有关系，都可以拥有独立的类集合。</div><div>使用其他类的时候，可以在类名前加上包名称，类似命名空间。也可以使用import的方式，import的时候可以使用*来导入包下的所有的类，但是不能导入所有的子包。</div><div><span style="font-size: 24px;">import（Java）和include（C++）的区别：前者可以使用类名前加包名来取代，但是C++的include虽然可以在命名空间中也加在类名前面，但是还是要include的，原因在于C++编译器是不知道代码文件的内部的，除了正在编译的文件。</span></div><div><span style="font-size: 24px;">静态导入静态方法和静态域。</span></div><div><span style="font-size: 24px;">包作用域使用public和private：默认在包中是对于同类的可以访问的。</span></div><div><span style="font-size: 24px;">包封闭问题。jar文件归档。</span></div><div><hr/></div><div>30、继承 关键字extends，都是共有继承（对于超类的方法是共有继承，域还是私有，可以通过super.方法来获取超类的域。），没有私有继承和保护继承。</div><div>子类 派生类 孩子类 -&gt; 父类 基类 超类。调用构造器的方法只能出现在其他构造器的第一句里。【因为java不支持多继承，所以不需要调用多个父类构造器函数，刚才我还在想呢？霍霍霍霍霍】这样表示先调用父类的构造器的意思。</div><div>重写，在子类中只要函数描述一样，就默认算是重写，不需要声明为虚拟方法。如果不希望可以被重写，则声明为final方法即可。java虚拟机知道引用对象具体的类型，从而调用对应类型的方法。</div><div><hr/></div><div>31、子类数组引用可以直接赋值超类的数组，不能反过来。不能直接使用超类的引用调用子类的方法，虽然这个超类的引用引用的是子类的对象也不行，可以调用重写的方法。子类可以直接转化为超类。</div><div>既然返回类型不是方法的签名描述，那么返回值不一样的方法算是重写吗？在java中是算得。在C++中编译器抱怨了。</div><div>java中的函数表实现动态绑定。无需对现存的代码进行修改重新编译，就可以进行扩展，可以引用新的对象。重写时方法权限不能降低。C++可以降低的。</div><div>final 来修饰方法，表明不再被子类重写，修饰类，表明所有的final类中的方法都不能被重写了并且阻止继承。不包括域。</div><div><hr/><div>32、强制类型转换 类对象引用的转换可能会触发虚拟机的异常曝出，可以先用一个 isstanceof来判断能否转化一个ok的执行。有点类似C++中的dynamic_cast只是此处因为是对象的强转，不会返回一个空，而是会返回一个异常，程序终止。很危险。</div></div><div><hr/><div>33、带有一个或者多个的抽象方法的类必须声明是一个抽象类。但是一个抽象类可以一个抽象方法都没有。</div></div><div><hr/></div><div>34、java中protected表示在子类或者包中其他的类中可见。</div><div>不带修饰符的默认是本包中可见。</div><div><hr/><div>35、超级类Object，就算没有写，也会默认继承自它，除了基础类型。C++中所有指针都可以转换为void*。</div></div><div><hr/></div><div>36、相等性比较：</div><div>java要求相等性要遵守：自反性、对称性、传递性、一致性。</div><div>什么时候用isstanceof和getClass来实现相等比较呢？如果子类决定就用后者，如果超类决定相等是否就用前者。</div><div>为了防止某些函数在子类中被重载而不是覆盖，可以使用@overwrite来标记。</div><div><hr/></div><div>37、hashCode 默认是对象存储地址。</div><div>如果重新定义了equals函数，就必须重新定义hashCode为了好好地放入到散列表中。</div><div><hr/><div>38、toString 自动调用，如果一个对象跟一个字符串相连，则java编译器就会自动调用。</div></div><div>最好使用getClass().getName作为类名，可以在继承中直接调用super.toString加上自己添加的域即可。System.out.println(对象）自动调用对象的toString（）方法。</div><div><hr/></div><div>39、泛型数组列表：可以省略右边的类型参数，菱形语法。</div><div>可以在new的时候指定容量，此时并没有元素，只是说自己的容量能力。</div><div><hr/><div>40、对象包装器（基础类型转换为一个对象） 自动装箱。自动拆箱。</div></div><div>就算对象包装了，也不能通过参数传递修改值，如果需要可以使用IntHolder。</div><div>参数数目可变的使用...</div><div><hr/></div><div>41、反射 class getClass/ forName /newInstance</div><div><hr/><div>42、接口用来描述功能，而不是具体的实现功能。接口中的方法默认是public的；但是在实现类中要声明为public的，否则会默认是包可见性，从而警告继承路径中造成了访问级别的降低。</div></div><div>不能有实例域和方法（静态或者非静态）的实现。但是可以包含常量，自动声明为public static final.</div><div>虽然接口不能构造一个对象，但是可以声明一个变量引用一个具体的接口类。</div><div>java不支持多重继承，但是可以多重实现几个接口是可以的哦。C++混合类可以添加默认行为。</div><div><hr/></div><div>43、clone方法，所有的数组类型都包含这个方法，所以可以深拷贝出来一个新的数组。</div><div>Object的clone方法是protected的，所以子类要重写可以提升为public，并且保留声明 throws CloneNotSupportedExpect 异常的关键字。</div><div><hr/></div><div>44、内部类包含外部类的引用。方法内的内部类可以使用参数。 代理，运行时生成指定类的对象。</div><div><hr/></div><div>45、Jar包里 类跟资源一起放在一起。部署程序。包密封，保证其他类不能打包进入这个包，从而访问包可见性的域或方法。</div><div><br/></div><div><img src="7. Java核心技术基础知识卷一_files/Image.png" type="image/png" data-filename="Image.png"/></div><div><img src="7. Java核心技术基础知识卷一_files/Image [1].png" type="image/png" data-filename="Image.png"/></div><div><hr/>
46、如果自己的方法别人可能使用，就要在方法声明时声明自己的方法可能抛出的异常。</div><div>Throwable具体为Error【java运行系统级内部错误，或者资源耗尽错误】 Exception【io或者RuntimeException】自己的错误。</div><div>可以声明已检查异常，未检查异常（Error或者继承自RuntimeException的异常）不要声明。</div><div>在捕获异常时，可以高效简洁地对于没有子类关系的异常合并捕获。</div><div>finally 最后的处理。try catch 加上 try finally语句。</div><div><img src="7. Java核心技术基础知识卷一_files/Image [2].png" type="image/png" data-filename="Image.png"/></div><div><br/></div><div>带资源的try语句自动关闭资源。</div><div><hr/></div><div>47、断言：如果断言失败，会抛出异常 AssertionErro，执行时可以通过传入 -enableassertionsg给类加载器，禁用或者打开断言，默认是禁用的。</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 